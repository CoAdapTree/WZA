
// set up a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

initialize() {

	defineConstant("optimaFile", "/home/booker/projects/def-whitlock/booker/GEA/slim_configs/BC_Map_environments.14x14.txt");

	defineConstant("N", 100);

	defineConstant("Vs", 192);

	defineConstant("sig_a", 0.5);

//	defineConstant("Ua", 0.0001);

//	defineConstant("REP", 1); // For saving files


// For an island model Fst is well described and we can set the migration rate using the theoretical expectation
	defineConstant("Fst", 0.05);

// Keep track of the tree sequence for the population
	initializeTreeSeq();

	mu = Ua/(1000*4); // the mutation rate for QTL

	initializeMutationRate(c(mu, mu ), c(1e6-1, 1e6+2999));
	
// m2 mutation type: QTL-type
	initializeMutationType("m2", 0.5, "n", 0.0, sig_a);
	
// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m2, 1.0);
	
// uniform chromosome of length 100 kb with uniform recombination	
//	genome = sort( makeGenome(100) );

// Initialise 10 QTL across the genome
	for (i in 0:9){
		for (j in 0:9999){
			if (j%100==0){
				initializeGenomicElement(g1, (49500+ (i*100000))+j-1, (49500+ (i*100000))+j);
			}
		}
	}
	initializeGenomicElement(g1, 1e6, 1e6+2999);

// Set up the recombination map such that there are 4 chromosomes - 1 focal chromosome and 3 cartoon chromosomes
	initializeRecombinationRate(c(1e-7,0.5,1e-4,0.5,1e-4,0.5,1e-4),
								c(1e6-1, 1e6, 1e6+999, 1e6+1000,1e6+1999,1e6+2000,1e6+2999));
}


1 late() {
	optima = readFile(optimaFile);	
	subpopCount = length(optima);
//	subpopCount = 100;

	tempID = "p999";
	sim.addSubpop(tempID, subpopCount*N);
}

// This is for dewvelopment, to keep track of how simulations are progressing
//1:30100 {
//	if (sim.generation%100 == 0){
//	cat(sim.generation + "\n");
//		}
//}

// the QTLs themselves are selectively neutral; their selective effect is generated by their contribution to the phenotype and that is handled below
fitness(m2) {
	return 1.0;
}

	
100 late(){
// We probably won't get a lot of substitutions, but let's turn them off because we want to keep a record of the phenotypes
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";
	
// Read a list of optima from a simple text file (one line/one entry per population).
// Make this a command line argument

	optima = readFile(optimaFile);

	subpopCount = length(optima);
//	subpopCount = 100;
	for (i in 0:(subpopCount-1)){
		sim.addSubpopSplit(i, N, p999);
		sim.subpopulations[i].tag = asInteger(optima[i]);
	}

// Reduce the initial subpopulation to 0 individuals 
	p999.setSubpopulationSize(0);
		
	sLen = asInteger(sqrt(subpopCount));

	mig = 5/(2*N);

	for (i in 1:subpopCount-1) {
		row = asInteger(i/sLen);
		col = asInteger(i - (sLen * row));
		focal = i;
		cat(focal + ' ' + row +' ' + col + ' ' + (focal - sLen) +'\n');
		
		// A 2D stepping stone model
		//	Left
		if (col != 0){
			sim.subpopulations[focal].setMigrationRates(focal-1, mig);
		}
		//	Right
		if (col < sLen-1){
			sim.subpopulations[focal].setMigrationRates(focal+1 , mig);
		}
		//	Up
		if (row > 0){
			sim.subpopulations[focal].setMigrationRates(focal - sLen  , mig);
		}
		//	Down
		if (row < sLen-1){
			sim.subpopulations[focal].setMigrationRates(focal+sLen, mig);
		}
	}

}

// After 20000 generations of adapting to a dumb optimum, impose a model of stabilising selection 
// All populations are adapting to the same optimum of 0.0 

101:200101 late() {
// construct phenotypes for the additive effects of QTLs. Do this in a vectorised kind of way
	inds = sim.subpopulations.individuals;	
	inds.z = inds.sumOfMutationsOfType(m2);

// Gaussian fitness function
	inds.fitnessScaling = exp( - ((inds.z - 0)^2)/(2*Vs));

}



200102:203101 late() {
// construct phenotypes for the additive effects of QTLs. Do this in a vectorised kind of way
	inds = sim.subpopulations.individuals;	
	inds.z = inds.sumOfMutationsOfType(m2);
	optimum = inds.subpopulation.tag;
//	inds.fitnessScaling = 1.0 + dnorm(optimum - inds.z, 0.0, 0.5);
	inds.fitnessScaling = exp( - ((optimum - inds.z)^2)/(2*Vs));

// Let's track local adaptation through time too
}


203102 early() {
	sim.treeSeqOutput(paste(c(REP,"_", sig_a,"_",Ua ,"_", Vs,".trees"), sep=""));
	
	head = "generation,pop,opt,phen";
	subpopCount = length(sim.subpopulations);
	writeFile(paste(c(REP,"_", sig_a,"_",Ua ,"_", Vs,".phen.txt"), sep=""), head);	
	for (pop in 0:(subpopCount-1)){
		for (ind in sim.subpopulations[pop].individuals){
			out = paste(c( sim.generation, pop, sim.subpopulations[pop].tag, ind.sumOfMutationsOfType(m2)), sep =',');
			writeFile(paste(c(REP,"_", sig_a,"_",Ua ,"_", Vs,".phen.txt"), sep=""), out, append=T);
			}
		}
	
	sim.simulationFinished();
}

